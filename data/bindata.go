// Code generated by go-bindata.
// sources:
// data/map.txt
// DO NOT EDIT!

package data

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _dataMapTxt = []byte(`# RUM SPNnc BLA BEL HOL DEN SPN SER ARM PIE GOL NTH NWY ADR POR NAF SWE SPNsc VEN ALB
# BLA TYN BEL SPN HOL DEN SPNnc RUM POR NAF SPNsc ALB ADR SWE ION NTH ARM NWY GOL SER
# AEG SPN DEN HOL TYN BEL BUL BLA EAS RUM BULnc SPNnc ALB ADR POR NAF BULsc SPNsc SWE SER NTH GOL ION NWY
# POR NAF BULsc SWE SPNsc ALB RUM GRE SPNnc BULnc HOL BUL BEL DEN SPN TUN SER NTH NWY
# NAF SPNsc BULsc ALB POR NTH SER BUL SPN BEL TUN HOL GRE BULnc SPNnc RUM
# SPNnc POR NAF SPNsc HOL BEL TUN SPN ALB
# BEL HOL

# ENGLAND
L\N\WAL\LON,LVP,YOR
W\N\WAL\IRI,ENG,LVP,LON
L\N\CLY\EDI,LVP
W\N\CLY\EDI,LVP,NAT,NRG
L\Y\LVP\YOR,EDI,CLY,WAL
W\Y\LVP\IRI,NAT,CLY,WAL
L\Y\EDI\YOR,LVP,CLY
W\Y\EDI\NTH,NRG,YOR,CLY
L\N\YOR\LVP,WAL,LON,EDI
W\N\YOR\EDI,LON,NTH
L\Y\LON\WAL,YOR
W\Y\LON\ENG,NTH,WAL,YOR

# FRANCE
L\Y\MAR\PIE,BUR,GAS,SPN
W\Y\MAR\PIE,GOL,SPNsc
L\N\GAS\BRE,PAR,BUR,MAR,SPN
W\N\GAS\BRE,MAO,SPNnc
L\Y\BRE\PIC,PAR,GAS
W\Y\BRE\ENG,MAO,GAS,PIC
L\N\PIC\BRE,BEL,PAR,BUR
W\N\PIC\ENG,BRE,BEL
L\Y\PAR\BRE,PIC,BUR,GAS
L\N\BUR\MAR,GAS,PAR,PIC,BEL,RUH,MUN

# GERMANY
L\N\RUH\BUR,BEL,HOL,KIE,MUN
L\Y\KIE\HOL,DEN,BER,MUN,RUH
W\Y\KIE\HOL,HEL,DEN,BAL,BER
L\Y\BER\KIE,PRU,SIL,MUN
W\Y\BER\KIE,BAL,PRU
L\N\PRU\BER,LVN,WAR,SIL
W\N\PRU\BER,BAL,LVN
L\N\SIL\MUN,BER,PRU,WAR,GAL,BOH
L\Y\MUN\BUR,RUH,KIE,BER,SIL,BOH,TYR

# RUSSIA
L\N\FIN\SWE,NWY,STP
W\N\FIN\BOT,SWE,STPsc
L\Y\STP\FIN,NWY,MOS,LVN
W\Y\STPsc\LVN,BOT,FIN
W\Y\STPnc\NWY,BAR
L\N\LVN\PRU,WAR,MOS,STP
W\N\LVN\PRU,BAL,BOT,STPsc
L\Y\MOS\SEV,UKR,WAR,LVN,STP
L\Y\WAR\GAL,SIL,PRU,LVN,MOS,UKR
L\N\UKR\RUM,GAL,WAR,MOS,SEV
L\Y\SEV\RUM,UKR,MOS,ARM
W\Y\SEV\ARM,BLA,RUM

# AUSTRIA
L\N\BOH\TYR,MUN,SIL,GAL,VIE
L\N\GAL\RUM,BUD,VIE,SIL,WAR,UKR,BOH
L\Y\VIE\TRI,TYR,BOH,GAL,BUD
L\Y\BUD\SER,TRI,VIE,GAL,RUM
L\Y\TRI\VEN,TYR,VIE,BUD,SER,ALB
W\Y\TRI\VEN,ADR,ALB
L\N\TYR\VEN,MUN,BOH,VIE,TRI,PIE

# ITALY
L\Y\VEN\APU,ROM,TUS,PIE,TYR,TRI
W\Y\VEN\TRI,ADR,APU
L\Y\TUS\PIE,VEN,ROM
W\Y\TUS\PIE,GOL,ROM,TYN
L\N\PIE\MAR,TYR,VEN,TUS
W\N\PIE\MAR,GOL,TUS
L\Y\ROM\TUS,VEN,APU,NAP
W\Y\ROM\TUS,TYN,NAP
L\Y\NAP\ROM,APU
W\Y\NAP\ION,TYN,ROM,APU
L\N\APU\VEN,ROM,NAP
W\N\APU\ADR,ION,VEN,NAP

# TURKEY
L\Y\CON\BUL,ANK,SMY
W\Y\CON\BLA,ANK,AEG,SMY,BULsc,BULnc
L\Y\ANK\CON,SMY,ARM
W\Y\ANK\CON,ARM,BLA
L\N\ARM\ANK,SMY,SYR,SEV
W\N\ARM\BLA,SEV,ANK
L\Y\SMY\CON,ANK,SYR,ARM
W\Y\SMY\CON,SYR,EAS,AEG
L\N\SYR\SMY,ARM
W\N\SYR\SMY,EAS

# UNOCCUPIED
L\Y\NWY\SWE,STP,FIN
W\Y\NWY\NRG,BAR,SWE,SKA,NTH,STPnc
L\Y\SWE\NWY,DEN,FIN
W\Y\SWE\BOT,BAL,DEN,SKA,NWY,FIN
L\Y\DEN\SWE,KIE
W\Y\DEN\NTH,SKA,SWE,BAL,KIE,HEL

L\Y\RUM\BUL,SER,BUD,GAL,UKR,SEV
W\Y\RUM\SEV,BLA,BULnc
L\Y\GRE\ALB,SER,BUL
W\Y\GRE\ION,ALB,AEG,BULsc
L\Y\BUL\RUM,SER,GRE,CON
W\Y\BULnc\RUM,CON,BLA
W\Y\BULsc\CON,GRE,AEG
L\Y\SER\ALB,TRI,BUD,RUM,BUL,GRE
L\N\ALB\TRI,SER,GRE
W\N\ALB\TRI,ADR,ION,GRE

L\Y\SPN\POR,GAS,MAR
W\Y\SPNnc\GAS,MAO,POR
W\Y\SPNsc\WES,GOL,MAR,POR,MAO
L\Y\POR\SPN
W\Y\POR\MAO,SPNsc,SPNnc
L\N\NAF\TUN
W\N\NAF\MAO,WES,TUN
L\Y\TUN\NAF
W\Y\TUN\NAF,WES,TYN,ION

L\Y\BEL\PIC,BUR,RUH,HOL
W\Y\BEL\PIC,ENG,NTH,HOL
L\Y\HOL\BEL,RUH,KIE
W\Y\HOL\NTH,HEL,KIE,BEL

# NORTH SEAS
W\N\MAO\NAT,IRI,ENG,BRE,GAS,POR,NAF,WES,SPNsc,SPNnc
W\N\ENG\MAO,BRE,PIC,BEL,LON,WAL,IRI,NTH
W\N\IRI\ENG,MAO,NAT,LVP,WAL
W\N\NAT\NRG,CLY,IRI,MAO,LVP
W\N\HEL\HOL,NTH,DEN,KIE
W\N\SKA\DEN,NTH,NWY,SWE
W\N\BAL\PRU,BER,KIE,DEN,SWE,BOT,LVN
W\N\BOT\SWE,FIN,LVN,BAL,STPsc
W\N\NRG\NTH,EDI,CLY,NAT,BAR,NWY
W\N\BAR\NWY,NRG,STPnc
W\N\NTH\HOL,BEL,ENG,LON,YOR,EDI,NRG,SKA,DEN,HEL,NWY

# SOUTH SEAS
W\N\WES\GOL,TYN,TUN,NAF,MAO,SPNsc
W\N\GOL\MAR,PIE,TUS,TYN,WES,SPNsc
W\N\TYN\TUS,ROM,NAP,ION,TUN,WES,GOL
W\N\ADR\VEN,TRI,ALB,ION,APU
W\N\ION\APU,ADR,ALB,GRE,AEG,EAS,TUN,TYN,NAP
W\N\AEG\ION,GRE,CON,SMY,EAS,BULsc
W\N\BLA\RUM,SEV,ARM,ANK,CON,BULnc
W\N\EAS\SMY,SYR,AEG,ION
`)

func dataMapTxtBytes() ([]byte, error) {
	return _dataMapTxt, nil
}

func dataMapTxt() (*asset, error) {
	bytes, err := dataMapTxtBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "data/map.txt", size: 170, mode: os.FileMode(438), modTime: time.Unix(1442537171, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"data/map.txt": dataMapTxt,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"data": &bintree{nil, map[string]*bintree{
		"map.txt": &bintree{dataMapTxt, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
